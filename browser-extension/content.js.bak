// Content script to scan form fields on the page
(async function() {
  const EXTENSION_VERSION = 'v2.0-20260116-2100';

  // Intercept console logs for content script
  const contentScriptLogs = [];
  const originalContentConsoleLog = console.log;
  console.log = function(...args) {
    const timestamp = new Date().toISOString();
    const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' ');
    const logEntry = `[${timestamp}] ${message}`;
    contentScriptLogs.push(logEntry);
    originalContentConsoleLog.apply(console, args);
  };

  console.log('ðŸ”§ Form scanner content script running:', EXTENSION_VERSION);

  /**
   * Send console logs to backend for debugging
   */
  function logToBackend(level, message) {
    fetch('http://localhost:5050/api/console-log', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({level, message, timestamp: new Date().toISOString()})
    }).catch(() => {});
  }

  /**
   * Detect new fields by comparing two scans
   * Returns fields in currentFields that weren't in previousFields
   * @param {Array} previousFields - Array of field objects from previous scan
   * @param {Array} currentFields - Array of field objects from current scan
   * @returns {Array} Fields that are new in currentFields
   */
  function getNewFields(previousFields, currentFields) {
    // Returns fields in currentFields that weren't in previousFields
    // Compare by field ID
    const previousIds = new Set(previousFields.map(f => f.id));
    return currentFields.filter(f => !previousIds.has(f.id));
  }

  /**
   * Get label text for a form field
   * Checks multiple sources: associated label, aria-label, placeholder
   */
  function getFieldLabel(element) {
    const candidates = [];

    // 1. Check button group labels (for file inputs)
    if (element.type === 'file') {
      const buttonGroup = element.closest('[role="group"], .file-upload, .button-container');
      if (buttonGroup) {
        // Check aria-labelledby on button group
        const labelledBy = buttonGroup.getAttribute('aria-labelledby');
        if (labelledBy) {
          const labelElement = document.getElementById(labelledBy);
          if (labelElement && labelElement.textContent.trim()) {
            candidates.push(labelElement.textContent.trim());
          }
        }

        // Check for label elements inside button group
        const groupLabels = buttonGroup.querySelectorAll('.label, .upload-label, [class*="label"]');
        groupLabels.forEach(label => {
          const text = label.textContent.trim();
          if (text) candidates.push(text);
        });
      }
    }

    // 2. Check label[for] element
    if (element.id) {
      const label = document.querySelector(`label[for="${element.id}"]`);
      if (label && label.textContent.trim()) {
        candidates.push(label.textContent.trim());
      }
    }

    // 3. Check parent label (field nested inside label)
    const parentLabel = element.closest('label');
    if (parentLabel && parentLabel.textContent.trim()) {
      let labelText = parentLabel.textContent.trim();
      // Remove element's own value from label text
      if (element.value) {
        labelText = labelText.replace(element.value, '').trim();
      }
      if (labelText) candidates.push(labelText);
    }

    // 4. Check aria-label attribute
    if (element.getAttribute('aria-label')) {
      candidates.push(element.getAttribute('aria-label').trim());
    }

    // 5. Check aria-labelledby on element itself
    if (element.getAttribute('aria-labelledby')) {
      const labelId = element.getAttribute('aria-labelledby');
      const labelElement = document.getElementById(labelId);
      if (labelElement && labelElement.textContent.trim()) {
        candidates.push(labelElement.textContent.trim());
      }
    }

    // 6. Check placeholder
    if (element.placeholder) {
      candidates.push(element.placeholder);
    }

    // 7. Check name attribute
    if (element.name) {
      candidates.push(element.name);
    }

    // Filter out empty, very short, or generic labels
    const genericWords = ['attach', 'upload', 'enter', 'select', 'choose', 'pick', 'file'];
    const filtered = candidates.filter(c => {
      if (!c || c.length < 3) return false;
      const lower = c.toLowerCase();
      // Keep it if it's not a single generic word
      return !genericWords.includes(lower);
    });

    // Return longest (most specific) label
    if (filtered.length > 0) {
      const longest = filtered.sort((a, b) => b.length - a.length)[0];
      console.log(`[getFieldLabel] Selected "${longest}" from candidates:`, candidates);
      return longest;
    }

    // Fallback to any candidate or [No label]
    return candidates[0] || '[No label]';
  }

  /**
   * Get the field type
   */
  function getFieldType(element) {
    // Check for ARIA role first
    const role = element.getAttribute('role');
    if (role === 'combobox' || role === 'listbox') {
      return 'combobox';
    }

    if (element.tagName === 'SELECT') {
      return 'select';
    }
    if (element.tagName === 'TEXTAREA') {
      return 'textarea';
    }
    if (element.tagName === 'INPUT') {
      return element.type || 'text';
    }
    return 'unknown';
  }

  /**
   * Get the current value of the field
   */
  function getFieldValue(element) {
    if (element.tagName === 'SELECT') {
      const selectedOption = element.options[element.selectedIndex];
      return selectedOption ? selectedOption.text : '';
    }
    if (element.type === 'checkbox' || element.type === 'radio') {
      return element.checked ? 'checked' : 'unchecked';
    }
    return element.value || '';
  }

  /**
   * Check if field is required
   */
  function isFieldRequired(element) {
    // Check required attribute
    if (element.required || element.hasAttribute('required')) {
      return true;
    }

    // Check aria-required
    if (element.getAttribute('aria-required') === 'true') {
      return true;
    }

    // Check for visual indicators in label (*, "required", etc.)
    const label = getFieldLabel(element);
    if (label.includes('*') || label.toLowerCase().includes('required')) {
      return true;
    }

    return false;
  }

  /**
   * Get hint/help text for a form field
   * Checks multiple sources: aria-describedby, adjacent help elements, container hints
   */
  function getFieldHint(element) {
    const hints = [];
    const elementId = element.id || element.name || 'unknown';

    // Helper function to add hint if not already present
    function addHint(text) {
      if (text && text.trim() && !hints.includes(text.trim())) {
        hints.push(text.trim());
      }
    }

    // 1. Check aria-describedby attribute (points to helper text element ID)
    const describedBy = element.getAttribute('aria-describedby');
    if (describedBy) {
      const hintElement = document.getElementById(describedBy);
      if (hintElement) {
        addHint(hintElement.innerText || hintElement.textContent);
        console.log('Field:', elementId, 'Found hint via aria-describedby:', hintElement.innerText || hintElement.textContent);
      }
    }

    // 2. Check element.nextElementSibling
    const nextSibling = element.nextElementSibling;
    if (nextSibling) {
      const text = nextSibling.innerText || nextSibling.textContent;
      if (text && text.trim().length > 0 && text.trim().length < 500) {
        // Reasonable length for hint
        addHint(text);
        console.log('Field:', elementId, 'Found hint in nextElementSibling:', text);
      }
    }

    // 3. Check parent element's nextElementSibling
    const parent = element.parentElement;
    if (parent && parent.nextElementSibling) {
      const text = parent.nextElementSibling.innerText || parent.nextElementSibling.textContent;
      if (text && text.trim().length > 0 && text.trim().length < 500) {
        addHint(text);
        console.log('Field:', elementId, 'Found hint in parent nextElementSibling:', text);
      }
    }

    // 4. Check for elements with id containing the input's id + "hint", "help", "desc"
    if (element.id) {
      const hintSuffixes = ['hint', 'help', 'desc', 'description', 'helper', 'note'];
      hintSuffixes.forEach(suffix => {
        const hintId = `${element.id}-${suffix}`;
        const hintElement = document.getElementById(hintId);
        if (hintElement) {
          addHint(hintElement.innerText || hintElement.textContent);
          console.log('Field:', elementId, 'Found hint via id pattern:', hintElement.innerText || hintElement.textContent);
        }

        // Also try without hyphen
        const hintIdNoDash = `${element.id}${suffix}`;
        const hintElementNoDash = document.getElementById(hintIdNoDash);
        if (hintElementNoDash) {
          addHint(hintElementNoDash.innerText || hintElementNoDash.textContent);
          console.log('Field:', elementId, 'Found hint via id pattern (no dash):', hintElementNoDash.innerText || hintElementNoDash.textContent);
        }
      });
    }

    // 5. Search within the input's closest div, fieldset, or label parent
    const container = element.closest('div, fieldset, label');
    if (container) {
      // Look for <small> tags
      const smallTags = container.querySelectorAll('small');
      smallTags.forEach(small => {
        if (!small.contains(element) && small !== element) {
          const text = small.innerText || small.textContent;
          if (text && text.trim().length > 0) {
            addHint(text);
            console.log('Field:', elementId, 'Found hint in <small> tag:', text);
          }
        }
      });

      // Look for elements with hint-related classes
      const hintKeywords = ['hint', 'help', 'description', 'helper', 'subscript', 'caption', 'note', 'sub'];
      hintKeywords.forEach(keyword => {
        const hintElements = container.querySelectorAll(`[class*="${keyword}" i]`);
        hintElements.forEach(hintEl => {
          if (!hintEl.contains(element) && hintEl !== element) {
            const text = hintEl.innerText || hintEl.textContent;
            if (text && text.trim().length > 0 && text.trim().length < 500) {
              addHint(text);
              console.log('Field:', elementId, `Found hint in .${keyword} class:`, text);
            }
          }
        });
      });
    }

    // Return combined hints or empty string
    const hintText = hints.length > 0 ? hints.join(' | ') : '';
    console.log('Field:', elementId, 'Final hint:', hintText);
    return hintText;
  }

  /**
   * Get the input type for better categorization
   */
  function getInputType(element) {
    // Check for ARIA role first
    const role = element.getAttribute('role');
    if (role === 'combobox' || role === 'listbox') {
      return 'combobox';
    }

    if (element.tagName === 'SELECT') {
      return 'select';
    }
    if (element.tagName === 'TEXTAREA') {
      return 'textarea';
    }
    if (element.tagName === 'INPUT') {
      const inputType = element.type || 'text';
      if (inputType === 'file') return 'file';
      if (inputType === 'radio') return 'radio'; // Will be grouped later
      if (inputType === 'checkbox') return 'checkbox'; // Will be grouped later
      return 'text'; // text, email, tel, url, number, etc.
    }
    return 'text';
  }

  /**
   * Extract options from a select element
   */
  function extractSelectOptions(selectElement) {
    const options = [];
    const optionElements = selectElement.querySelectorAll('option');

    // Limit to first 20 options if too many
    const limit = Math.min(optionElements.length, 20);

    for (let i = 0; i < limit; i++) {
      const option = optionElements[i];
      options.push({
        value: option.value || '',
        text: option.textContent.trim()
      });
    }

    return options;
  }

  /**
   * Try to find options for Greenhouse/custom dropdown fields
   * Greenhouse often uses custom dropdowns that aren't standard <select> elements
   */
  /**
   * Extract dropdown options synchronously (Strategies 1-4 only)
   */
  function extractCustomDropdownOptionsSync(element) {
    const elementId = element.id || element.name || 'unknown';
    console.log(`[extractCustomDropdownOptionsSync] Checking element: ${elementId}`);

    // Strategy 1: Look for a select element with matching name or ID
    if (element.name || element.id) {
      // Try finding by exact name match
      if (element.name) {
        const selectByName = document.querySelector(`select[name="${element.name}"]`);
        if (selectByName && selectByName !== element) {
          const opts = extractSelectOptions(selectByName);
          if (opts.length > 0) {
            console.log(`[Strategy 1] Found ${opts.length} options for ${elementId} via name match`);
            return opts;
          }
        }
      }

      // Try finding by exact ID match (hidden select might have same ID with suffix)
      if (element.id) {
        const selectById = document.querySelector(`select[id="${element.id}"], select[id="${element.id}_select"], select[data-for="${element.id}"]`);
        if (selectById && selectById !== element) {
          const opts = extractSelectOptions(selectById);
          if (opts.length > 0) {
            console.log(`[Strategy 1] Found ${opts.length} options for ${elementId} via ID match`);
            return opts;
          }
        }
      }
    }

    // Strategy 2: DISABLED - Too unreliable, matches unrelated select elements
    // (Was matching phone country selector for all fields)
    // If you need this, use Strategy 1 (explicit ID/name matching) or Strategy 3 (aria-controls)

    // Strategy 3: Look for aria-controls (points to option list)
    const controlsId = element.getAttribute('aria-controls');
    if (controlsId) {
      const listbox = document.getElementById(controlsId);
      if (listbox) {
        const options = [];
        const optionElements = listbox.querySelectorAll('[role="option"], li, .option, .select-option');
        const limit = Math.min(optionElements.length, 20);

        for (let i = 0; i < limit; i++) {
          const opt = optionElements[i];
          const text = opt.textContent.trim();
          const value = opt.getAttribute('data-value') || opt.getAttribute('value') || text;
          if (text) {
            options.push({ value, text });
          }
        }

        if (options.length > 0) {
          return options;
        }
      }
    }

    // Strategy 4: Look for common Greenhouse dropdown patterns
    // Greenhouse often wraps fields in divs with classes like 'field', 'select-wrapper', etc.
    let container = element.closest('.field, .form-field, .select-wrapper, .custom-select, [data-field-type]');
    if (container) {
      // Look for option elements within the container
      const optionElements = container.querySelectorAll(
        '[role="option"], .option, .select-option, [data-option-value], li[data-value]'
      );

      if (optionElements.length > 0) {
        const options = [];
        const limit = Math.min(optionElements.length, 20);

        for (let i = 0; i < limit; i++) {
          const opt = optionElements[i];
          const text = opt.textContent.trim();
          const value = opt.getAttribute('data-value') ||
                       opt.getAttribute('data-option-value') ||
                       opt.getAttribute('value') ||
                       text;
          if (text && text !== '') {
            options.push({ value, text });
          }
        }

        if (options.length > 0) {
          return options;
        }
      }
    }

    return null;
  }

  /**
   * Infer Yes/No options for boolean-looking questions
   */
  function inferYesNoOptions(element) {
    const label = getFieldLabel(element).toLowerCase();
    const hint = getFieldHint(element).toLowerCase();
    const combinedText = `${label} ${hint}`;

    // Check if this looks like a yes/no question
    const yesNoPatterns = [
      /\b(are you|do you|did you|have you|will you|would you|can you|is )\b/i,
      /\b(open to|willing to|require|need)\b/i,
      /\?(.*)?$/  // Ends with question mark
    ];

    const looksLikeBooleanQuestion = yesNoPatterns.some(pattern => pattern.test(combinedText));

    // Check for specific keywords that strongly suggest yes/no
    const strongBooleanKeywords = [
      'sponsorship', 'visa', 'relocation', 'relocate', 'open to',
      'willing to', 'interviewed', 'worked at', 'clearance'
    ];
    const hasStrongKeyword = strongBooleanKeywords.some(keyword => combinedText.includes(keyword));

    // Check for acknowledgment/consent patterns (like "AI Policy", "Terms", etc.)
    const acknowledgmentPatterns = [
      /\b(policy|policies|guideline|guidelines|terms|agreement)\b/i,
      /\b(confirm|acknowledge|agree|consent|accept|understand|reviewed?|read)\b/i,
      /\b(select|selecting|choose|click)\s+(yes|no)/i,  // Hint mentions selecting yes/no
      /yes\b.*\bno\b|no\b.*\byes\b/i  // Hint mentions both "yes" and "no"
    ];
    const looksLikeAcknowledgment = acknowledgmentPatterns.some(pattern => pattern.test(combinedText));

    if (looksLikeBooleanQuestion || hasStrongKeyword || looksLikeAcknowledgment) {
      console.log(`Inferring Yes/No options for field: ${element.id || element.name} (label: "${label}")`);
      return [
        { value: 'Yes', text: 'Yes' },
        { value: 'No', text: 'No' }
      ];
    }

    return null;
  }

  /**
   * Extract dropdown options with runtime triggering (async)
   * Triggers ALL comboboxes to extract their options during scan
   */
  async function extractCustomDropdownOptions(element) {
    console.log(`[SCAN] Extracting options for ${element.id || element.name}...`);

    // Try sync extraction first (Strategies 1-4)
    let options = extractCustomDropdownOptionsSync(element);

    // If we found real options from sync extraction, return them
    if (options && options.length > 2) {
      console.log(`[SCAN] Found ${options.length} options via sync extraction for ${element.id || element.name}`);
      return options;
    }

    // For ALL comboboxes, trigger dropdown to extract options
    const isCombobox = element.getAttribute('role') === 'combobox' ||
                      element.getAttribute('aria-haspopup') === 'listbox' ||
                      element.getAttribute('aria-autocomplete') === 'list';

    if (isCombobox) {
      console.log(`[SCAN] ======== Triggering combobox: ${element.id || element.name} ========`);

      try {
        // STEP 1: Close ALL existing dropdowns before opening this one
        console.log(`[SCAN] Closing all existing dropdowns...`);
        const allListboxes = document.querySelectorAll('[role="listbox"], [role="menu"], [role="dialog"]');
        allListboxes.forEach(lb => {
          lb.style.display = 'none';
          lb.style.visibility = 'hidden';
          lb.setAttribute('aria-hidden', 'true');
        });

        // Snapshot visible listboxes BEFORE clicking
        const listboxesBeforeClick = Array.from(document.querySelectorAll('[role="listbox"], [role="menu"]'))
          .filter(lb => {
            const style = window.getComputedStyle(lb);
            return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
          });
        console.log(`[SCAN] Visible listboxes BEFORE click: ${listboxesBeforeClick.length}`);

        // STEP 2: Aggressively trigger dropdown to open
        console.log(`[SCAN] Triggering dropdown with multiple methods...`);

        // Focus first
        element.focus();
        await new Promise(resolve => setTimeout(resolve, 200));

        // Mouse events
        element.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
        element.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true }));

        // Click
        element.click();

        // Set ARIA expanded
        element.setAttribute('aria-expanded', 'true');

        // Wait LONGER for dropdown to load and render
        console.log(`[SCAN] Waiting 1000ms for dropdown to appear...`);
        await new Promise(resolve => setTimeout(resolve, 1000));

        // STEP 3: Find the listbox that opened
        console.log(`[SCAN] Looking for opened listbox...`);

        // Look for listbox via aria-controls
        const controlsId = element.getAttribute('aria-controls');
        let listbox = null;

        if (controlsId) {
          listbox = document.getElementById(controlsId);
          if (listbox) {
            console.log(`[SCAN] âœ“ Found listbox via aria-controls: ${controlsId}`);
          }
        }

        // If not found, find NEW visible listboxes that appeared AFTER clicking
        if (!listbox) {
          const listboxesAfterClick = Array.from(document.querySelectorAll('[role="listbox"], [role="menu"]'))
            .filter(lb => {
              const style = window.getComputedStyle(lb);
              const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
              if (isVisible) {
                console.log(`[SCAN] Found visible listbox:`, lb.id || lb.className, {
                  display: style.display,
                  visibility: style.visibility,
                  opacity: style.opacity
                });
              }
              return isVisible;
            });

          // Find listboxes that are new (weren't visible before)
          const newListboxes = listboxesAfterClick.filter(lb => !listboxesBeforeClick.includes(lb));

          console.log(`[SCAN] Visible listboxes AFTER click: ${listboxesAfterClick.length}, NEW: ${newListboxes.length}`);

          if (newListboxes.length === 1) {
            listbox = newListboxes[0];
            console.log(`[SCAN] âœ“ Using newly appeared listbox:`, listbox.id || listbox.className);
          } else if (newListboxes.length > 1) {
            // Multiple new listboxes - find the closest one spatially
            console.log(`[SCAN] Multiple new listboxes, finding closest...`);
            const elementRect = element.getBoundingClientRect();
            let closestListbox = null;
            let minDistance = Infinity;

            for (const lb of newListboxes) {
              const lbRect = lb.getBoundingClientRect();
              const distance = Math.abs(lbRect.top - elementRect.bottom);
              console.log(`[SCAN] Listbox ${lb.id || lb.className} distance:`, distance);
              if (distance < minDistance && distance < 300) { // Max 300px away
                minDistance = distance;
                closestListbox = lb;
              }
            }

            if (closestListbox) {
              listbox = closestListbox;
              console.log(`[SCAN] âœ“ Using closest new listbox (distance: ${minDistance}px):`, listbox.id || listbox.className);
            }
          } else if (newListboxes.length === 0 && listboxesAfterClick.length > 0) {
            // No NEW listboxes, but there are visible ones - might be same dropdown reopening
            console.log(`[SCAN] No new listboxes, checking existing visible ones...`);
            const elementRect = element.getBoundingClientRect();
            for (const lb of listboxesAfterClick) {
              const lbRect = lb.getBoundingClientRect();
              const distance = Math.abs(lbRect.top - elementRect.bottom);
              if (distance < 300) {
                listbox = lb;
                console.log(`[SCAN] âœ“ Using nearby existing listbox (distance: ${distance}px):`, listbox.id || listbox.className);
                break;
              }
            }
          }
        }

        // STEP 4: Extract options from listbox
        if (listbox) {
          const optionElements = listbox.querySelectorAll('[role="option"], li, .option, [data-value]');
          console.log(`[SCAN] Found ${optionElements.length} option elements in listbox`);

          if (optionElements.length > 0) {
            const extractedOptions = [];
            const limit = Math.min(optionElements.length, 100); // Increased limit

            for (let i = 0; i < limit; i++) {
              const opt = optionElements[i];
              const text = opt.textContent.trim();
              const value = opt.getAttribute('data-value') ||
                           opt.getAttribute('value') ||
                           text;

              if (text && text !== '') {
                extractedOptions.push({ value, text });
              }
            }

            if (extractedOptions.length > 0) {
              console.log(`[SCAN] âœ“âœ“âœ“ Successfully extracted ${extractedOptions.length} options for ${element.id || element.name}`);
              console.log(`[SCAN] First 5 options:`, extractedOptions.slice(0, 5).map(o => o.text));
              options = extractedOptions;
            } else {
              console.warn(`[SCAN] âš ï¸ Found option elements but none had text`);
            }
          } else {
            console.warn(`[SCAN] âš ï¸ Listbox found but has no option elements`);
          }
        } else {
          console.error(`[SCAN] âŒ No listbox found for ${element.id || element.name}`);
        }

        // STEP 5: Close dropdown definitively
        console.log(`[SCAN] ======== Closing dropdown for ${element.id || element.name} ========`);

        // Method 1: If we found the listbox, forcibly hide it
        if (listbox) {
          console.log(`[SCAN] Hiding listbox directly...`);
          listbox.style.display = 'none';
          listbox.style.visibility = 'hidden';
          listbox.style.opacity = '0';
          listbox.setAttribute('aria-hidden', 'true');
        }

        // Method 2: Set aria-expanded to false on element
        if (element.getAttribute('aria-expanded') === 'true') {
          element.setAttribute('aria-expanded', 'false');
          console.log(`[SCAN] Set aria-expanded=false`);
        }

        // Method 3: Send Escape key
        element.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape', code: 'Escape', keyCode: 27, bubbles: true }));
        element.dispatchEvent(new KeyboardEvent('keyup', { key: 'Escape', code: 'Escape', keyCode: 27, bubbles: true }));

        // Method 4: Blur the element
        element.blur();

        // Method 5: Click body to close any modal overlays
        document.body.click();

        // Wait for dropdown to fully close
        await new Promise(resolve => setTimeout(resolve, 500));

        // STEP 6: Verify closure
        const stillVisible = Array.from(document.querySelectorAll('[role="listbox"], [role="menu"]'))
          .filter(lb => {
            const style = window.getComputedStyle(lb);
            return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
          });

        if (stillVisible.length > 0) {
          console.warn(`[SCAN] âš ï¸ ${stillVisible.length} listbox(es) still visible after closing!`);
          // Force close them
          stillVisible.forEach(lb => {
            lb.style.display = 'none';
            lb.style.visibility = 'hidden';
            lb.setAttribute('aria-hidden', 'true');
          });
        } else {
          console.log(`[SCAN] âœ“ All dropdowns closed successfully`);
        }

      } catch (error) {
        console.warn(`[SCAN] Error extracting options for ${element.id || element.name}:`, error);
      }
    }

    return options;
  }

  /**
   * Extract information from a form field
   */
  async function extractFieldInfo(element, options = null) {
    const fieldInfo = {
      label: getFieldLabel(element),
      hint: getFieldHint(element),
      type: getFieldType(element),
      input_type: getInputType(element),
      name: element.name || '',
      id: element.id || '',
      required: isFieldRequired(element),
      value: getFieldValue(element),
      placeholder: element.placeholder || '',
      autocomplete: element.getAttribute('autocomplete') || ''
    };

    // Generate ID from label if element has no ID
    if (!fieldInfo.id) {
      console.log('ðŸ” [CHECKPOINT:extractFieldInfo:NoID]', {
        type: fieldInfo.input_type,
        label: fieldInfo.label,
        name: fieldInfo.name,
        placeholder: fieldInfo.placeholder
      });

      let generatedId = '';
      let idSource = '';

      // Try to generate from label
      if (fieldInfo.label) {
        generatedId = fieldInfo.label
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .substring(0, 50);
        idSource = 'label';
        console.log('ðŸ” [CHECKPOINT:extractFieldInfo:IDFromLabel]', { label: fieldInfo.label, generated: generatedId });
      }
      // Fallback to name
      else if (fieldInfo.name) {
        generatedId = fieldInfo.name;
        idSource = 'name';
        console.log('ðŸ” [CHECKPOINT:extractFieldInfo:IDFromName]', { name: fieldInfo.name, generated: generatedId });
      }
      // Last resort: use placeholder
      else if (fieldInfo.placeholder) {
        generatedId = fieldInfo.placeholder
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .substring(0, 50);
        idSource = 'placeholder';
        console.log('ðŸ” [CHECKPOINT:extractFieldInfo:IDFromPlaceholder]', { placeholder: fieldInfo.placeholder, generated: generatedId });
      }

      // Prefix with input type for clarity
      if (generatedId) {
        const prefix = fieldInfo.input_type === 'combobox' ? 'combobox_' :
                      fieldInfo.input_type === 'custom_select' ? 'custom_select_' :
                      'field_';
        fieldInfo.id = prefix + generatedId;

        // Actually set the ID on the DOM element so it can be found later
        element.setAttribute('id', fieldInfo.id);
        console.log('âœ… [CHECKPOINT:extractFieldInfo:IDGenerated]', {
          finalId: fieldInfo.id,
          source: idSource,
          prefix: prefix,
          elementSet: element.id === fieldInfo.id
        });
      } else {
        console.log('âŒ [CHECKPOINT:extractFieldInfo:IDGenerationFailed] No label, name, or placeholder available');
      }
    }

    // Add options for select elements
    if (element.tagName === 'SELECT') {
      fieldInfo.options = extractSelectOptions(element);
    }
    // Try to detect custom dropdown options ONLY for actual comboboxes (e.g., Greenhouse)
    // DO NOT extract options for plain text inputs - they'll get matched by nearby select elements
    else if (element.getAttribute('role') === 'combobox' ||
             element.getAttribute('aria-haspopup') === 'listbox' ||
             element.getAttribute('aria-autocomplete') === 'list') {
      console.log(`[SCAN] Detected combobox: ${element.id || element.name} (role=${element.getAttribute('role')}, aria-haspopup=${element.getAttribute('aria-haspopup')})`);
      const customOptions = await extractCustomDropdownOptions(element);
      if (customOptions && customOptions.length > 0) {
        console.log(`[SCAN] âœ“ Stored ${customOptions.length} options for ${element.id || element.name}`);
        fieldInfo.options = customOptions;
        fieldInfo.input_type = 'custom_select';  // Mark as custom select for backend
      } else {
        console.log(`[SCAN] âœ— No options extracted for combobox ${element.id || element.name}`);
      }
    }

    // Add options for radio/checkbox groups (passed from scanFormFields)
    if (options) {
      fieldInfo.options = options;
    }

    return fieldInfo;
  }

  /**
   * Check if element is visible
   */
  function isVisible(element) {
    const style = window.getComputedStyle(element);
    return style.display !== 'none' && style.visibility !== 'hidden';
  }

  /**
   * Get text content for button/link
   */
  function getElementText(element) {
    // Get direct text content, trimmed
    let text = element.textContent.trim();

    // For buttons with no text, try aria-label or value
    if (!text && element.getAttribute('aria-label')) {
      text = element.getAttribute('aria-label').trim();
    }
    if (!text && element.value) {
      text = element.value.trim();
    }

    return text || '[No text]';
  }

  /**
   * Get label text for a radio/checkbox option
   */
  function getOptionLabel(element) {
    // For radio/checkbox, try to get the specific label for this option
    if (element.id) {
      const label = document.querySelector(`label[for="${element.id}"]`);
      if (label && label.textContent.trim()) {
        return label.textContent.trim();
      }
    }

    // Try parent label
    const parentLabel = element.closest('label');
    if (parentLabel) {
      // Clone the label and remove the input element to get just the text
      const clone = parentLabel.cloneNode(true);
      const inputs = clone.querySelectorAll('input');
      inputs.forEach(input => input.remove());
      const text = clone.textContent.trim();
      if (text) return text;
    }

    // Try next sibling text node
    let sibling = element.nextSibling;
    while (sibling) {
      if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent.trim()) {
        return sibling.textContent.trim();
      }
      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.textContent.trim()) {
        return sibling.textContent.trim();
      }
      sibling = sibling.nextSibling;
    }

    return element.value || '[No label]';
  }

  /**
   * Find all form fields on the page
   */
  /**
   * Detect button-based form fields (common in modern UIs)
   * These are groups of buttons/divs that act as selectable options
   */
  function detectButtonFields() {
    const buttonFields = [];

    console.log('=== BUTTON FIELD DETECTION DEBUG ===');

    // Look for common patterns:
    // 1. Multiple buttons within a container that share aria-labelledby or data attributes
    // 2. Buttons with role="radio" or similar
    // 3. Clickable divs/buttons grouped together

    // Pattern 1: Find containers with multiple button-like children
    const containers = document.querySelectorAll([
      '[role="radiogroup"]',
      '[role="group"]',
      '.button-group',
      '.radio-group',
      '.options-group',
      '[class*="question"]',
      '[class*="field"]',
      '[class*="input"]',
      '[data-field]',
      'fieldset'
    ].join(', '));

    console.log(`Found ${containers.length} potential button field containers`);

    containers.forEach((container, idx) => {
      console.log(`\nContainer ${idx}:`, {
        tagName: container.tagName,
        classes: container.className,
        id: container.id,
        role: container.getAttribute('role'),
        innerHTML: container.innerHTML.substring(0, 200) + '...' // Preview HTML
      });

      // Try multiple selectors to find button-like elements
      let buttons = container.querySelectorAll('button:not([type="submit"]):not([type="button"][class*="next"]):not([class*="back"]), [role="radio"], [role="button"]:not([class*="submit"]):not([class*="next"]):not([class*="back"])');

      console.log(`  Selector 1 (standard buttons): ${buttons.length} found`);

      // If no buttons found, try more generic selectors (Ashby often uses divs)
      if (buttons.length === 0) {
        buttons = container.querySelectorAll('div[role="button"], div[tabindex], span[role="button"], [class*="option"]:not(select option), [class*="choice"], [data-option], [class*="button"]:not(button[type="submit"])');
        console.log(`  Selector 2 (divs/spans): ${buttons.length} found before filtering`);

        // Filter to only visible, clickable elements
        const originalCount = buttons.length;
        buttons = Array.from(buttons).filter(btn => {
          const style = window.getComputedStyle(btn);
          return style.display !== 'none' &&
                 style.visibility !== 'hidden' &&
                 btn.offsetParent !== null &&
                 (btn.onclick || btn.getAttribute('role') === 'button' || btn.tabIndex >= 0);
        });
        console.log(`  After filtering: ${buttons.length} (removed ${originalCount - buttons.length} hidden/non-clickable)`);
      }

      // If still nothing, try looking for ANY direct children that might be options
      if (buttons.length === 0) {
        const directChildren = Array.from(container.children);
        buttons = directChildren.filter(child => {
          const text = child.textContent.trim();
          const hasShortText = text.length > 0 && text.length < 30;
          const hasClickHandler = child.onclick ||
                                 child.getAttribute('onclick') ||
                                 child.style.cursor === 'pointer' ||
                                 child.classList.toString().match(/clickable|button|option|choice/i);
          return hasShortText && (hasClickHandler || child.getAttribute('role'));
        });
        console.log(`  Selector 3 (direct children): ${buttons.length} found`);
      }

      console.log(`  Total buttons found: ${buttons.length}`);

      if (buttons.length >= 2 && buttons.length <= 10) { // Reasonable range for options
        // Check if these look like option buttons (similar styling, short text)
        const buttonTexts = Array.from(buttons).map(b => b.textContent.trim());
        const avgLength = buttonTexts.reduce((sum, t) => sum + t.length, 0) / buttonTexts.length;

        console.log(`  Button texts:`, buttonTexts);
        console.log(`  Average text length: ${avgLength}`);

        // If buttons have short text (likely options not actions), treat as field
        if (avgLength < 30) {
          // Find the label/question
          let label = '';

          // Try aria-labelledby
          const labelledBy = container.getAttribute('aria-labelledby');
          if (labelledBy) {
            const labelElement = document.getElementById(labelledBy);
            if (labelElement) label = labelElement.textContent.trim();
          }

          // Try label, legend, or preceding heading
          if (!label) {
            const labelElement = container.querySelector('label, legend');
            if (labelElement) label = labelElement.textContent.trim();
          }

          if (!label) {
            const heading = container.querySelector('h1, h2, h3, h4, h5, h6, [class*="question"], [class*="label"]');
            if (heading) label = heading.textContent.trim();
          }

          // Look for label as previous sibling
          if (!label && container.previousElementSibling) {
            const prev = container.previousElementSibling;
            if (prev.tagName.match(/^H[1-6]$/) || prev.classList.toString().match(/label|question/i)) {
              label = prev.textContent.trim();
            }
          }

          // Generate field ID from container or first button
          let fieldId = container.id ||
                       container.getAttribute('data-field-id') ||
                       container.getAttribute('data-question-id') ||
                       buttons[0].id ||
                       buttons[0].getAttribute('name') ||
                       '';

          console.log('ðŸ” [CHECKPOINT:detectButtonFields:IDLookup]', {
            containerId: container.id,
            dataFieldId: container.getAttribute('data-field-id'),
            firstButtonId: buttons[0].id,
            foundId: fieldId,
            label: label
          });

          // If no ID, generate one from the label
          if (!fieldId && label) {
            const rawGenerated = label
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, '_')
              .replace(/^_+|_+$/g, '')
              .substring(0, 50);

            fieldId = 'button_group_' + rawGenerated;

            console.log('ðŸ” [CHECKPOINT:detectButtonFields:GeneratingID]', {
              label: label,
              rawGenerated: rawGenerated,
              finalId: fieldId
            });

            // Set the generated ID on the container element so it can be found later
            container.setAttribute('id', fieldId);
            const verifySet = container.id === fieldId;

            console.log('âœ… [CHECKPOINT:detectButtonFields:IDSetOnDOM]', {
              fieldId: fieldId,
              elementIdAfterSet: container.id,
              successfullySet: verifySet
            });
          }

          if (label || fieldId) {
            console.log(`  âœ“ Creating button field:`, { id: fieldId, label, optionCount: buttons.length });

            buttonFields.push({
              id: fieldId,
              name: container.getAttribute('name') || fieldId,
              label: label || '[Button group]',
              type: 'button_group',
              input_type: 'button_group',
              required: container.getAttribute('aria-required') === 'true' ||
                       container.hasAttribute('required') ||
                       label.includes('*'),
              value: '',
              options: Array.from(buttons).map(btn => ({
                value: btn.getAttribute('value') ||
                       btn.getAttribute('data-value') ||
                       btn.textContent.trim(),
                text: btn.textContent.trim(),
                selected: btn.getAttribute('aria-checked') === 'true' ||
                         btn.classList.contains('selected') ||
                         btn.classList.contains('active')
              })),
              hint: container.getAttribute('aria-describedby') ?
                   document.getElementById(container.getAttribute('aria-describedby'))?.textContent.trim() || '' : '',
              placeholder: '',
              autocomplete: ''
            });
          } else {
            console.log(`  âœ— Skipped: No label or fieldId found`);
          }
        } else {
          console.log(`  âœ— Skipped: Average text length ${avgLength} >= 30`);
        }
      } else {
        console.log(`  âœ— Skipped: ${buttons.length} buttons (need 2-10)`);
      }
    });

    console.log(`=== END BUTTON FIELD DETECTION (found ${buttonFields.length} fields) ===\n`);

    return buttonFields;
  }

  /**
   * Re-scan form fields to capture any newly visible fields
   * Performs full extraction (including clicking dropdowns) for NEW fields only
   * @param {Array} previousFieldIds - Array of field IDs from previous scan to skip
   * @returns {Array} Array of NEW field objects only
   */
  async function rescanFormFields(previousFieldIds = []) {
    console.log(`ðŸ”„ Rescan: Skipping ${previousFieldIds.length} previously scanned fields`);

    const previousIdSet = new Set(previousFieldIds);
    const newFields = [];

    // Query DOM for all form field elements
    const inputs = document.querySelectorAll('input, select, textarea, [role="combobox"], [role="listbox"]');

    for (const element of inputs) {
      // Skip hidden/button/submit inputs
      if (element.type === 'hidden' || element.type === 'submit' ||
          element.type === 'button' || element.type === 'image' || element.type === 'reset') {
        continue;
      }

      // Skip if not visible
      if (!isVisible(element)) {
        continue;
      }

      // Generate field ID using SAME logic as initial scan
      let fieldId = element.id || element.name;
      if (!fieldId) {
        const label = getFieldLabel(element);
        if (label) {
          const inputType = getInputType(element);
          const prefix = inputType === 'combobox' ? 'combobox_' :
                        inputType === 'custom_select' ? 'custom_select_' :
                        'field_';
          fieldId = prefix + label.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '').substring(0, 50);
        } else if (element.name) {
          fieldId = element.name;
        } else if (element.placeholder) {
          const inputType = getInputType(element);
          const prefix = inputType === 'combobox' ? 'combobox_' :
                        inputType === 'custom_select' ? 'custom_select_' :
                        'field_';
          fieldId = prefix + element.placeholder.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '').substring(0, 50);
        }
      }

      // If ID is in previousFieldIds â†’ skip entirely
      if (fieldId && previousIdSet.has(fieldId)) {
        continue;
      }

      // This is a NEW field - do full extraction
      const fieldType = getFieldType(element);
      const inputType = getInputType(element);
      console.log(`ðŸ†• Rescan: New field detected: ${fieldId} (${fieldType}/${inputType})`);

      try {
        const fieldInfo = {
          label: getFieldLabel(element),
          hint: getFieldHint(element),
          type: fieldType,
          input_type: inputType,
          name: element.name || '',
          id: fieldId || '',
          required: isFieldRequired(element),
          value: getFieldValue(element),
          placeholder: element.placeholder || '',
          autocomplete: element.getAttribute('autocomplete') || ''
        };

        // Set the generated ID on the DOM element (same as initial scan)
        if (!element.id && fieldId) {
          element.setAttribute('id', fieldId);
        }

        // For SELECT elements, extract options (no clicking needed)
        if (element.tagName === 'SELECT') {
          fieldInfo.options = extractSelectOptions(element);
        }
        // For comboboxes, do FULL async extraction (click to open, extract options)
        else if (element.getAttribute('role') === 'combobox' ||
                 element.getAttribute('aria-haspopup') === 'listbox' ||
                 element.getAttribute('aria-autocomplete') === 'list') {
          console.log(`   â†³ Clicking to extract dropdown options...`);
          const customOptions = await extractCustomDropdownOptions(element);
          if (customOptions && customOptions.length > 0) {
            fieldInfo.options = customOptions;
            fieldInfo.input_type = 'custom_select';
          }
        }

        newFields.push(fieldInfo);
      } catch (error) {
        console.error(`Rescan: error extracting field ${fieldId}:`, error);
      }
    }

    console.log(`ðŸ”„ Rescan complete: ${newFields.length} new fields found`);
    return newFields;
  }

  async function scanFormFields() {
    // Find all input, select, and textarea elements, plus comboboxes
    const inputs = document.querySelectorAll('input, select, textarea, [role="combobox"], [role="listbox"]');
    const formFields = [];
    const radioGroups = new Map(); // name -> [elements]
    const checkboxGroups = new Map(); // name -> [elements]
    const processedNames = new Set(); // Track processed group names

    // Use for...of instead of forEach to support await
    for (const element of inputs) {
      // Skip hidden inputs and buttons
      if (element.type === 'hidden' ||
          element.type === 'submit' ||
          element.type === 'button' ||
          element.type === 'image' ||
          element.type === 'reset') {
        continue;
      }

      // For selects, include even if hidden - they might have custom UI
      const isHiddenSelect = element.tagName === 'SELECT' && !isVisible(element);

      // Skip if element is not visible (except hidden selects with custom UI)
      if (!isVisible(element) && !isHiddenSelect) {
        continue;
      }

      // If it's a hidden select, check if there's visible custom UI for it
      if (isHiddenSelect) {
        // Look for associated visible UI (common patterns: sibling div, wrapper with same name/id)
        const parent = element.parentElement;
        let hasVisibleUI = false;

        if (parent) {
          // Check for visible siblings or wrapper elements
          const siblings = Array.from(parent.children);
          hasVisibleUI = siblings.some(sibling =>
            sibling !== element &&
            isVisible(sibling) &&
            (sibling.classList.toString().match(/select|dropdown|combo|picker/i) ||
             sibling.getAttribute('role') === 'combobox')
          );
        }

        if (!hasVisibleUI) {
          continue; // Skip truly hidden selects with no UI
        }
      }

      // Group radio buttons by name
      if (element.type === 'radio' && element.name) {
        if (!radioGroups.has(element.name)) {
          radioGroups.set(element.name, []);
        }
        radioGroups.get(element.name).push(element);
        continue; // Don't process individually
      }

      // Group checkboxes by name (if multiple with same name exist)
      if (element.type === 'checkbox' && element.name) {
        if (!checkboxGroups.has(element.name)) {
          checkboxGroups.set(element.name, []);
        }
        checkboxGroups.get(element.name).push(element);
        continue; // Don't process individually for now
      }

      // Process all other elements normally
      try {
        const fieldInfo = await extractFieldInfo(element);
        formFields.push(fieldInfo);
      } catch (error) {
        console.error('Error extracting field info:', error, element);
      }
    }

    // Process radio button groups
    for (const [name, elements] of radioGroups) {
      if (elements.length === 0) continue;

      try {
        // Use the first element as the base for the field info
        const firstElement = elements[0];
        const fieldInfo = await extractFieldInfo(firstElement);

        // Override input_type to indicate it's a group
        fieldInfo.input_type = 'radio_group';

        // Extract options from all radio buttons in the group
        fieldInfo.options = elements.map(el => ({
          value: el.value || '',
          text: getOptionLabel(el),
          checked: el.checked
        }));

        // Get the group label (usually from fieldset legend or common label)
        const fieldset = firstElement.closest('fieldset');
        if (fieldset) {
          const legend = fieldset.querySelector('legend');
          if (legend && legend.textContent.trim()) {
            fieldInfo.label = legend.textContent.trim();
          }
        }

        formFields.push(fieldInfo);
      } catch (error) {
        console.error('Error extracting radio group info:', error, name);
      }
    }

    // Process checkbox groups (only if multiple checkboxes share the same name)
    for (const [name, elements] of checkboxGroups) {
      if (elements.length === 0) continue;

      try {
        // If only one checkbox with this name, treat it as individual
        if (elements.length === 1) {
          const fieldInfo = await extractFieldInfo(elements[0]);
          formFields.push(fieldInfo);
          continue;
        }

        // Multiple checkboxes with same name - treat as group
        const firstElement = elements[0];
        const fieldInfo = await extractFieldInfo(firstElement);

        // Override input_type to indicate it's a group
        fieldInfo.input_type = 'checkbox_group';

        // Extract options from all checkboxes in the group
        fieldInfo.options = elements.map(el => ({
          value: el.value || '',
          text: getOptionLabel(el),
          checked: el.checked
        }));

        // Get the group label (usually from fieldset legend or common label)
        const fieldset = firstElement.closest('fieldset');
        if (fieldset) {
          const legend = fieldset.querySelector('legend');
          if (legend && legend.textContent.trim()) {
            fieldInfo.label = legend.textContent.trim();
          }
        }

        formFields.push(fieldInfo);
      } catch (error) {
        console.error('Error extracting checkbox group info:', error, name);
      }
    }

    // Detect button-based fields (modern UI pattern)
    try {
      const buttonFields = detectButtonFields();
      if (buttonFields.length > 0) {
        console.log(`Found ${buttonFields.length} button-based field(s)`);
        formFields.push(...buttonFields);
      }
    } catch (error) {
      console.error('Error detecting button fields:', error);
    }

    return formFields;
  }

  /**
   * Capture context clues for company name extraction
   * Returns various page elements that might contain the company name
   */
  function captureCompanyNameContext() {
    try {
      const context = {
        nav_links: [],
        headings: [],
        company_links: [],
        form_labels: [],
        page_title: document.title || ''
      };

    // Capture navigation links (top of page, often contain company homepage)
    const navElements = document.querySelectorAll('nav a, header a, [role="navigation"] a');
    navElements.forEach(link => {
      const text = link.textContent.trim();
      const href = link.href || '';
      // Skip empty, very long text, or common navigation words
      if (text.length > 0 && text.length < 50 &&
          !text.toLowerCase().match(/^(home|about|careers|jobs|login|sign|apply|back|menu|search)$/)) {
        context.nav_links.push({ text, href });
      }
    });
    // Limit to first 10 nav links to avoid noise
    context.nav_links = context.nav_links.slice(0, 10);

    // Capture page headings (h1, h2, h3)
    const headings = document.querySelectorAll('h1, h2, h3');
    headings.forEach(heading => {
      const text = heading.textContent.trim();
      if (text.length > 0 && text.length < 100) {
        context.headings.push(text);
      }
    });
    // Limit to first 5 headings
    context.headings = context.headings.slice(0, 5);

    // Capture links that might go to company homepage
    const companyLinkPatterns = [
      /company/i,
      /employer/i,
      /organization/i,
      /about/i
    ];
    const allLinks = document.querySelectorAll('a[href]');
    allLinks.forEach(link => {
      const text = link.textContent.trim();
      const href = link.href || '';
      const isCompanyLink = companyLinkPatterns.some(pattern =>
        pattern.test(text) || pattern.test(link.className) || pattern.test(link.id)
      );
      if (isCompanyLink && text.length > 0 && text.length < 50) {
        context.company_links.push({ text, href });
      }
    });
    // Limit to first 5 company links
    context.company_links = context.company_links.slice(0, 5);

    // Capture form labels (often contain company name in questions)
    const labels = document.querySelectorAll('label');
    labels.forEach(label => {
      const text = label.textContent.trim();
      if (text.length > 0 && text.length < 200) {
        context.form_labels.push(text);
      }
    });
    // Also capture aria-labels from inputs
    const ariaLabels = document.querySelectorAll('[aria-label]');
    ariaLabels.forEach(el => {
      const ariaLabel = el.getAttribute('aria-label');
      if (ariaLabel) {
        const text = ariaLabel.trim();
        if (text.length > 0 && text.length < 200) {
          context.form_labels.push(text);
        }
      }
    });
    // Also capture legends (used for fieldsets)
    const legends = document.querySelectorAll('legend');
    legends.forEach(legend => {
      const text = legend.textContent.trim();
      if (text.length > 0 && text.length < 200) {
        context.form_labels.push(text);
      }
    });
    // Limit to first 20 form labels to avoid excessive data
    context.form_labels = context.form_labels.slice(0, 20);

    console.log('âœ“ Captured company name context successfully:', context);
    logToBackend('info', `âœ“ Captured company name context: ${context.headings.length} headings, ${context.nav_links.length} nav links, ${context.form_labels.length} form labels`);
    return context;
  } catch (error) {
      console.error('âŒ Error capturing company name context:', error);
      logToBackend('error', `âŒ Error capturing company name context: ${error.message}`);
      // Return minimal context on error
      return {
        nav_links: [],
        headings: [],
        company_links: [],
        form_labels: [],
        page_title: document.title || '',
        error: error.message
      };
    }
  }

  /**
   * Extract job details from the page
   * Returns {company_name, role_title, job_description, company_name_context}
   */
  function extractJobDetails() {
    const result = {
      company_name: '',
      role_title: '',
      job_location: '',
      job_description: '',
      company_name_context: null
    };

    // --- Extract Company Name ---
    // Try common ATS URL patterns first (fast and reliable)
    const url = window.location.href;

    // Greenhouse: boards.greenhouse.io/company_name/jobs/...
    if (url.includes('greenhouse.io')) {
      const match = url.match(/greenhouse\.io\/([^\/]+)/);
      if (match && match[1]) {
        const slug = match[1];
        result.company_name = slug.charAt(0).toUpperCase() + slug.slice(1);
      }
    }

    // Lever: jobs.lever.co/company_name/...
    if (!result.company_name && url.includes('lever.co')) {
      const match = url.match(/lever\.co\/([^\/]+)/);
      if (match && match[1]) {
        const slug = match[1];
        result.company_name = slug.charAt(0).toUpperCase() + slug.slice(1);
      }
    }

    // Try JSON-LD structured data (common across many sites)
    if (!result.company_name) {
      const jsonLdScripts = document.querySelectorAll('script[type="application/ld+json"]');
      for (const script of jsonLdScripts) {
        try {
          const data = JSON.parse(script.textContent);
          if (data.hiringOrganization && data.hiringOrganization.name) {
            result.company_name = data.hiringOrganization.name.trim();
            break;
          }
          if (data.author && data.author.name) {
            result.company_name = data.author.name.trim();
            break;
          }
        } catch (e) {
          // Skip invalid JSON
        }
      }
    }

    // Try multiple meta tags
    if (!result.company_name) {
      const metaTags = [
        'meta[property="og:site_name"]',
        'meta[name="author"]',
        'meta[name="company"]',
        'meta[property="og:author"]',
        'meta[name="application-name"]'
      ];

      for (const selector of metaTags) {
        const meta = document.querySelector(selector);
        if (meta && meta.content && meta.content.trim().length > 0) {
          const content = meta.content.trim();
          // Skip generic or too long values
          if (content.length < 50 && !content.includes('http') && !content.toLowerCase().includes('jobs')) {
            result.company_name = content;
            break;
          }
        }
      }
    }

    // Try common DOM selectors used by various ATS platforms
    if (!result.company_name) {
      const selectors = [
        '.company-name',
        '.employer-name',
        '[data-company-name]',
        '[class*="company" i]:not(button):not(a)',
        '[class*="employer" i]:not(button):not(a)',
        '.job-company',
        '.posting-company'
      ];

      for (const selector of selectors) {
        const element = document.querySelector(selector);
        if (element) {
          const text = element.textContent.trim();
          // Skip if too long (likely contains more than just company name)
          if (text.length > 0 && text.length < 50 && !text.includes('\n')) {
            result.company_name = text;
            break;
          }
        }
      }
    }

    // Try page title with better parsing
    if (!result.company_name && document.title) {
      const title = document.title.trim();

      // Common patterns: "Job Title - Company" or "Job Title | Company" or "Job Title at Company"
      const patterns = [
        /\sat\s+([^-|]+)$/i,           // "... at Company"
        /[-|]\s*([^-|]+)\s*$/,          // "... - Company" or "... | Company" (last part)
        /^([^-|]+)\s*[-|]/              // "Company - ..." or "Company | ..." (first part if short)
      ];

      for (const pattern of patterns) {
        const match = title.match(pattern);
        if (match && match[1]) {
          const candidate = match[1].trim();
          // Only accept if it looks like a company name (short, not containing job-related words)
          if (candidate.length > 0 && candidate.length < 50 &&
              !candidate.toLowerCase().includes('job') &&
              !candidate.toLowerCase().includes('career') &&
              !candidate.toLowerCase().includes('apply')) {
            result.company_name = candidate;
            break;
          }
        }
      }
    }

    // Try data attributes
    if (!result.company_name) {
      const dataElement = document.querySelector('[data-company], [data-employer], [data-organization]');
      if (dataElement) {
        const dataCompany = dataElement.getAttribute('data-company') ||
                           dataElement.getAttribute('data-employer') ||
                           dataElement.getAttribute('data-organization');
        if (dataCompany && dataCompany.trim().length > 0) {
          result.company_name = dataCompany.trim();
        }
      }
    }

    // --- Extract Role Title ---
    // Try og:title meta tag
    const ogTitle = document.querySelector('meta[property="og:title"]');
    if (ogTitle && ogTitle.content) {
      result.role_title = ogTitle.content.trim();
    }

    // Try <h1> element
    if (!result.role_title) {
      const h1 = document.querySelector('h1');
      if (h1 && h1.textContent) {
        result.role_title = h1.textContent.trim();
      }
    }

    // Try element with class containing "title", "position", "job-title", "role"
    if (!result.role_title) {
      const titleElement = document.querySelector(
        '[class*="job-title" i], [class*="jobtitle" i], [class*="position" i], [class*="role" i], [class*="job_title" i]'
      );
      if (titleElement && titleElement.textContent) {
        result.role_title = titleElement.textContent.trim();
      }
    }

    // Try page title (extract job title before " - " or " | ")
    if (!result.role_title && document.title) {
      const titleParts = document.title.split(/\s+[-|]\s+/);
      if (titleParts.length > 0) {
        // Often the first part is the job title
        result.role_title = titleParts[0].trim();
      }
    }

    // --- Extract Job Location ---
    // Look for elements with location-related classes or attributes
    const locationSelectors = [
      '[class*="location" i]',
      '[class*="job-location" i]',
      '[class*="job_location" i]',
      '[data-location]',
      '[itemprop="jobLocation"]',
      '[itemprop="addressLocality"]',
      '.location',
      '.job-location'
    ];

    for (const selector of locationSelectors) {
      const locationElement = document.querySelector(selector);
      if (locationElement) {
        let locationText = '';

        // Try data attribute first
        if (locationElement.getAttribute('data-location')) {
          locationText = locationElement.getAttribute('data-location').trim();
        } else if (locationElement.textContent) {
          locationText = locationElement.textContent.trim();
        }

        // Clean up the location text
        if (locationText && locationText.length > 0 && locationText.length < 100) {
          // Remove common prefixes
          locationText = locationText.replace(/^(location|where):\s*/i, '').trim();
          result.job_location = locationText;
          console.log(`ðŸ“ Found job location: "${result.job_location}"`);
          break;
        }
      }
    }

    // Try to extract from page title (often includes location)
    // e.g., "Product Manager - Mountain View, CA"
    if (!result.job_location && document.title) {
      const locationPatterns = [
        /,\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?),?\s+([A-Z]{2})/,  // "City, State" e.g., "Mountain View, CA"
        /,\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/,                  // Just "City"
        /[-|]\s*([A-Z][a-z]+,\s*[A-Z]{2})/                       // "- City, State"
      ];

      for (const pattern of locationPatterns) {
        const match = document.title.match(pattern);
        if (match) {
          result.job_location = match[0].replace(/^[-|,]\s*/, '').trim();
          console.log(`ðŸ“ Extracted location from title: "${result.job_location}"`);
          break;
        }
      }
    }

    // Look near the job title for location
    if (!result.job_location) {
      const h1 = document.querySelector('h1');
      if (h1) {
        // Check siblings or nearby elements
        const parent = h1.parentElement;
        if (parent) {
          const nearbyText = parent.textContent;
          const locationMatch = nearbyText.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?),?\s+([A-Z]{2})/);
          if (locationMatch && locationMatch[0]) {
            result.job_location = locationMatch[0].trim();
            console.log(`ðŸ“ Found location near title: "${result.job_location}"`);
          }
        }
      }
    }

    // --- Extract Job Description ---
    // Try main content area
    const mainElement = document.querySelector('main, [role="main"]');
    if (mainElement) {
      result.job_description = mainElement.textContent.trim();
    }

    // Try element with class containing "description" or "content"
    if (!result.job_description) {
      const descElement = document.querySelector(
        '[class*="description" i], [class*="job-description" i], [class*="job_description" i], [class*="content" i]'
      );
      if (descElement && descElement.textContent) {
        result.job_description = descElement.textContent.trim();
      }
    }

    // Try <article> tags
    if (!result.job_description) {
      const article = document.querySelector('article');
      if (article && article.textContent) {
        result.job_description = article.textContent.trim();
      }
    }

    // Clean up extracted text (remove extra whitespace)
    result.company_name = result.company_name.replace(/\s+/g, ' ').trim();
    result.role_title = result.role_title.replace(/\s+/g, ' ').trim();
    result.job_location = result.job_location.replace(/\s+/g, ' ').trim();
    result.job_description = result.job_description.replace(/\s+/g, ' ').trim();

    // Truncate job description if too long (keep first 5000 chars)
    if (result.job_description.length > 5000) {
      result.job_description = result.job_description.substring(0, 5000) + '...';
    }

    // Capture context for company name validation
    console.log("ðŸ” DEBUG: About to capture company name context...");
    logToBackend('debug', 'ðŸ” About to capture company name context');
    result.company_name_context = captureCompanyNameContext();
    console.log("ðŸ” DEBUG: Context captured, value:", result.company_name_context);

    // DEBUG: Log captured context details
    if (result.company_name_context) {
      const contextSummary = {
        url_company: result.company_name,
        page_title: result.company_name_context.page_title,
        headings_count: result.company_name_context.headings ? result.company_name_context.headings.length : 0,
        nav_links_count: result.company_name_context.nav_links ? result.company_name_context.nav_links.length : 0,
        form_labels_count: result.company_name_context.form_labels ? result.company_name_context.form_labels.length : 0,
        company_links_count: result.company_name_context.company_links ? result.company_name_context.company_links.length : 0,
        headings: result.company_name_context.headings,
        nav_links: result.company_name_context.nav_links,
        form_labels: result.company_name_context.form_labels ? result.company_name_context.form_labels.slice(0, 5) : [],
        company_links: result.company_name_context.company_links,
        has_error: result.company_name_context.error
      };
      console.log("ðŸ” DEBUG: Captured company name context:", contextSummary);
      logToBackend('debug', `ðŸ” Context summary: URL=${result.company_name}, title="${result.company_name_context.page_title}", headings=${contextSummary.headings_count}, nav=${contextSummary.nav_links_count}, labels=${contextSummary.form_labels_count}`);
      logToBackend('debug', `ðŸ” Headings: ${JSON.stringify(result.company_name_context.headings)}`);
      logToBackend('debug', `ðŸ” Nav links: ${JSON.stringify(result.company_name_context.nav_links)}`);
      logToBackend('debug', `ðŸ” First 5 form labels: ${JSON.stringify(result.company_name_context.form_labels.slice(0, 5))}`);
    } else {
      console.error("ðŸ” DEBUG: Context is null or undefined!");
      logToBackend('error', 'ðŸ” Context is null or undefined!');
    }

    return result;
  }

  /**
   * Find all action elements (buttons, submit inputs, links)
   */
  function scanActions() {
    const actions = [];

    // 1. Find all <button> elements
    const buttons = document.querySelectorAll('button');
    buttons.forEach((button) => {
      if (!isVisible(button)) return;

      try {
        actions.push({
          type: 'button',
          text: getElementText(button),
          buttonType: button.type || 'button',
          id: button.id || '',
          class: button.className || '',
          href: ''
        });
      } catch (error) {
        console.error('Error extracting button info:', error, button);
      }
    });

    // 2. Find <input type="submit"> and <input type="button">
    const inputButtons = document.querySelectorAll('input[type="submit"], input[type="button"]');
    inputButtons.forEach((input) => {
      if (!isVisible(input)) return;

      try {
        actions.push({
          type: 'input-button',
          text: input.value || getElementText(input),
          buttonType: input.type,
          id: input.id || '',
          class: input.className || '',
          href: ''
        });
      } catch (error) {
        console.error('Error extracting input button info:', error, input);
      }
    });

    // 3. Find elements with role="button"
    const roleButtons = document.querySelectorAll('[role="button"]');
    roleButtons.forEach((element) => {
      if (!isVisible(element)) return;
      // Skip if already captured as a <button> element
      if (element.tagName === 'BUTTON') return;

      try {
        actions.push({
          type: 'role-button',
          text: getElementText(element),
          buttonType: '',
          id: element.id || '',
          class: element.className || '',
          href: ''
        });
      } catch (error) {
        console.error('Error extracting role button info:', error, element);
      }
    });

    // 4. Find links with keywords: "apply", "upload", "submit", "linkedin"
    const links = document.querySelectorAll('a');
    const keywords = ['apply', 'upload', 'submit', 'linkedin'];

    links.forEach((link) => {
      if (!isVisible(link)) return;

      const text = getElementText(link).toLowerCase();
      const href = (link.href || '').toLowerCase();

      // Check if text or href contains any of the keywords
      const hasKeyword = keywords.some(keyword =>
        text.includes(keyword) || href.includes(keyword)
      );

      if (hasKeyword) {
        try {
          actions.push({
            type: 'link',
            text: getElementText(link),
            buttonType: '',
            id: link.id || '',
            class: link.className || '',
            href: link.href || ''
          });
        } catch (error) {
          console.error('Error extracting link info:', error, link);
        }
      }
    });

    return actions;
  }

  /**
   * Fuzzy match a value against option values/text
   * Handles case-insensitivity, boolean equivalents, and common variations
   */
  function fuzzyMatchOption(value, optionValue, optionText) {
    // Convert to strings for comparison
    const val = String(value).toLowerCase().trim();
    const optVal = String(optionValue).toLowerCase().trim();
    const optTxt = String(optionText).toLowerCase().trim();

    // Exact match (case-insensitive)
    if (val === optVal || val === optTxt) {
      return true;
    }

    // Boolean equivalents
    const trueValues = ['true', 'yes', '1', 't', 'y'];
    const falseValues = ['false', 'no', '0', 'f', 'n'];

    if (trueValues.includes(val)) {
      return trueValues.includes(optVal) || trueValues.includes(optTxt);
    }

    if (falseValues.includes(val)) {
      return falseValues.includes(optVal) || falseValues.includes(optTxt);
    }

    // Country variations
    const countryVariations = {
      'united states': ['us', 'usa', 'u.s.', 'u.s.a.', 'united states of america'],
      'united kingdom': ['uk', 'u.k.', 'great britain', 'gb'],
      'canada': ['ca', 'can'],
      // Add more as needed
    };

    for (const [canonical, variations] of Object.entries(countryVariations)) {
      if (val === canonical || variations.includes(val)) {
        if (optVal === canonical || variations.includes(optVal) ||
            optTxt === canonical || variations.includes(optTxt)) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Fill form fields with provided values
   * NOTE: Currently not used directly - the fill logic is injected from popup.js
   * This function is kept here for reference and potential future use
   * @param {Object} fillValues - Object mapping field IDs/names to values
   * @returns {Object} - Summary of filled fields and errors
   */
  async function fillFormFields(fillValues) {
    console.log('Filling form fields with values:', fillValues);

    const results = {
      filled: [],
      errors: [],
      notFound: []
    };

    for (const [fieldIdentifier, value] of Object.entries(fillValues)) {
      try {
        // Try to find the element by ID first, then by name
        let element = document.getElementById(fieldIdentifier);
        if (!element) {
          element = document.querySelector(`[name="${fieldIdentifier}"]`);
        }

        // If still not found, try array index
        if (!element && /^\d+$/.test(fieldIdentifier)) {
          const inputs = document.querySelectorAll('input, select, textarea');
          element = inputs[parseInt(fieldIdentifier)];
        }

        if (!element) {
          console.warn(`Field not found: ${fieldIdentifier}`);
          results.notFound.push(fieldIdentifier);
          continue;
        }

        // Handle different field types
        const fieldType = getFieldType(element);

        if (fieldType === 'checkbox') {
          // Handle checkbox fields - use fuzzy matching for boolean values
          const val = String(value).toLowerCase().trim();
          const trueValues = ['true', 'yes', '1', 't', 'y'];
          const falseValues = ['false', 'no', '0', 'f', 'n'];

          if (value === true || trueValues.includes(val)) {
            element.checked = true;

            // Dispatch events to trigger any listeners
            element.dispatchEvent(new Event('click', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));

            console.log(`Checked checkbox: ${fieldIdentifier}`);
            results.filled.push({ field: fieldIdentifier, type: 'checkbox', value: true });
          } else if (value === false || falseValues.includes(val)) {
            element.checked = false;

            element.dispatchEvent(new Event('click', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));

            console.log(`Unchecked checkbox: ${fieldIdentifier}`);
            results.filled.push({ field: fieldIdentifier, type: 'checkbox', value: false });
          }
        } else if (fieldType === 'radio') {
          // Handle radio buttons - use fuzzy matching for boolean values
          const val = String(value).toLowerCase().trim();
          const trueValues = ['true', 'yes', '1', 't', 'y'];

          if (value === true || trueValues.includes(val)) {
            element.checked = true;

            element.dispatchEvent(new Event('click', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));

            console.log(`Selected radio: ${fieldIdentifier}`);
            results.filled.push({ field: fieldIdentifier, type: 'radio', value: true });
          }
        } else if (fieldType === 'select') {
          // Handle select dropdowns with fuzzy matching
          // Try exact match first
          let option = Array.from(element.options).find(opt =>
            opt.value === String(value) || opt.text === String(value)
          );

          // If no exact match, try fuzzy matching
          if (!option) {
            option = Array.from(element.options).find(opt =>
              fuzzyMatchOption(value, opt.value, opt.text)
            );
          }

          if (option) {
            element.value = option.value;
            element.dispatchEvent(new Event('change', { bubbles: true }));

            console.log(`Set select: ${fieldIdentifier} = ${option.text} (matched from: ${value})`);
            results.filled.push({ field: fieldIdentifier, type: 'select', value: option.text });
          } else {
            console.warn(`Option not found in select ${fieldIdentifier}:`, value);
            console.warn(`Available options:`, Array.from(element.options).map(o => `"${o.value}" / "${o.text}"`));
            results.errors.push({ field: fieldIdentifier, error: 'Option not found' });
          }
        } else if (element.getAttribute('role') === 'combobox' ||
                   element.getAttribute('aria-haspopup') === 'listbox' ||
                   element.getAttribute('aria-autocomplete') === 'list') {
          // Handle custom dropdowns (like Greenhouse)
          console.log(`Handling custom dropdown ${fieldIdentifier}...`);

          // Click to open dropdown
          element.focus();
          element.click();

          // Wait for dropdown to open
          await new Promise(resolve => setTimeout(resolve, 600));

          // Look for aria-controls to find the dropdown menu
          const controlsId = element.getAttribute('aria-controls');
          let listbox = null;

          if (controlsId) {
            listbox = document.getElementById(controlsId);
          }

          // If not found, search for visible listboxes
          if (!listbox) {
            const visibleListboxes = Array.from(document.querySelectorAll('[role="listbox"], [role="menu"]'))
              .filter(lb => {
                const style = window.getComputedStyle(lb);
                return style.display !== 'none' && style.visibility !== 'hidden';
              });

            if (visibleListboxes.length > 0) {
              listbox = visibleListboxes[0];
            }
          }

          if (listbox) {
            // Extract options from listbox
            const optionElements = listbox.querySelectorAll('[role="option"], li, .option');
            console.log(`Found ${optionElements.length} options in dropdown for ${fieldIdentifier}`);

            // Find matching option using fuzzy matching
            let matchedOption = null;
            for (const opt of optionElements) {
              const optText = opt.textContent.trim();
              const optValue = opt.getAttribute('data-value') || opt.getAttribute('value') || optText;

              if (optValue === String(value) || optText === String(value)) {
                matchedOption = opt;
                break;
              }
            }

            // Try fuzzy match if exact match not found
            if (!matchedOption) {
              for (const opt of optionElements) {
                const optText = opt.textContent.trim();
                const optValue = opt.getAttribute('data-value') || opt.getAttribute('value') || optText;

                if (fuzzyMatchOption(value, optValue, optText)) {
                  matchedOption = opt;
                  break;
                }
              }
            }

            if (matchedOption) {
              // Click the matched option
              matchedOption.click();
              matchedOption.dispatchEvent(new Event('click', { bubbles: true }));

              console.log(`âœ“ Selected option in ${fieldIdentifier}: ${matchedOption.textContent.trim()}`);
              results.filled.push({ field: fieldIdentifier, type: 'custom_select', value: matchedOption.textContent.trim() });

              // Wait a bit then close dropdown
              await new Promise(resolve => setTimeout(resolve, 200));
              element.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape', code: 'Escape', keyCode: 27, bubbles: true }));
              element.blur();
            } else {
              console.warn(`Option not found in custom dropdown ${fieldIdentifier}:`, value);
              console.warn(`Available options:`, Array.from(optionElements).map(o => o.textContent.trim()).slice(0, 10));
              results.errors.push({ field: fieldIdentifier, error: 'Option not found' });

              // Close dropdown
              element.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape', code: 'Escape', keyCode: 27, bubbles: true }));
              element.blur();
            }
          } else {
            console.warn(`No listbox found for ${fieldIdentifier}, falling back to direct input`);
            element.value = String(value);
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            element.blur();
          }

          // Small delay between fields to avoid interference
          await new Promise(resolve => setTimeout(resolve, 200));
        } else {
          // Handle text inputs, textareas, etc.
          element.value = String(value);

          // Dispatch input and change events
          element.dispatchEvent(new Event('input', { bubbles: true }));
          element.dispatchEvent(new Event('change', { bubbles: true }));

          console.log(`Set field: ${fieldIdentifier} = ${value}`);
          results.filled.push({ field: fieldIdentifier, type: fieldType, value: value });
        }

      } catch (error) {
        console.error(`Error filling field ${fieldIdentifier}:`, error);
        results.errors.push({ field: fieldIdentifier, error: error.message });
      }
    }

    console.log('Fill results:', results);
    return results;
  }

  // Set up message listener for rescan requests and log retrieval
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'rescanFormFields') {
      console.log('ðŸ”„ Rescan requested via message');
      console.log('Message received, previousFieldIds:', request.previousFieldIds);
      console.log('previousFieldIds length:', request.previousFieldIds?.length);
      rescanFormFields(request.previousFieldIds || []).then(fields => {
        console.log(`ðŸ”„ Rescan complete: ${fields.length} fields found`);
        sendResponse({ fields });
      }).catch(error => {
        console.error('ðŸ”„ Rescan error:', error);
        sendResponse({ fields: [], error: error.message });
      });
      return true; // async response
    }

    if (request.action === 'getConsoleLogs') {
      console.log('ðŸ“‹ Console logs requested');
      sendResponse({ logs: contentScriptLogs.join('\n') });
      return true;
    }
  });

  // Execute the scan and return results
  const fields = await scanFormFields();
  const actions = scanActions();
  const jobDetails = extractJobDetails();

  console.log(`Found ${fields.length} form fields and ${actions.length} actions`);
  console.log('Fields:', fields);
  console.log('Actions:', actions);
  console.log('Job Details:', jobDetails);

  // Return the results (this will be received by popup.js)
  return {
    fields: fields,
    actions: actions,
    jobDetails: jobDetails
  };
})();
