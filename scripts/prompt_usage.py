#!/usr/bin/env python3
"""
Scan all Python files in the project and track prompt usage.
Generates a map of which prompts are used in which files.
"""

import re
from pathlib import Path
from collections import defaultdict


def scan_file_for_prompts(file_path: Path) -> list[tuple[str, int]]:
    """
    Scan a Python file for prompt references.

    Args:
        file_path: Path to Python file to scan

    Returns:
        List of tuples: (prompt_filename, line_number)
    """
    prompts_found = []

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        for line_num, line in enumerate(lines, start=1):
            # Pattern 1: load_prompt("filename.md")
            load_prompt_matches = re.findall(r'load_prompt\(["\']([^"\']+)["\']', line)
            for match in load_prompt_matches:
                prompts_found.append((match, line_num))

            # Pattern 2: Direct reference to prompts/*.md
            direct_matches = re.findall(r'prompts/([a-z_]+\.md)', line)
            for match in direct_matches:
                prompts_found.append((match, line_num))

            # Pattern 3: Path operations with prompt files
            path_matches = re.findall(r'["\']([a-z_]+_prompt\.md)["\']', line)
            for match in path_matches:
                if match not in [p[0] for p in prompts_found]:
                    prompts_found.append((match, line_num))

    except Exception as e:
        print(f"Error reading {file_path}: {e}")

    return prompts_found


def find_all_python_files(root_dir: Path) -> list[Path]:
    """
    Find all Python files in the project.

    Args:
        root_dir: Root directory to search

    Returns:
        List of Python file paths
    """
    python_files = []

    # Exclude certain directories
    exclude_dirs = {'venv', '__pycache__', '.git', 'node_modules', '.vscode'}

    for py_file in root_dir.rglob('*.py'):
        # Check if file is in an excluded directory
        if any(excluded in py_file.parts for excluded in exclude_dirs):
            continue
        python_files.append(py_file)

    return sorted(python_files)


def find_all_prompts(prompts_dir: Path) -> list[str]:
    """
    Find all .md files in the prompts directory.

    Args:
        prompts_dir: Path to prompts directory

    Returns:
        List of prompt filenames
    """
    if not prompts_dir.exists():
        return []

    prompts = []
    for md_file in prompts_dir.glob('*.md'):
        if md_file.name != 'README.md' and md_file.name != 'USAGE.md':
            prompts.append(md_file.name)

    return sorted(prompts)


def generate_usage_map(root_dir: Path) -> dict:
    """
    Generate a map of prompt usage across the project.

    Args:
        root_dir: Root directory of the project

    Returns:
        Dictionary mapping prompt files to usage locations
    """
    usage_map = defaultdict(list)

    python_files = find_all_python_files(root_dir)
    print(f"Scanning {len(python_files)} Python files...")

    for py_file in python_files:
        # Skip this script itself to avoid false positives from examples
        if py_file.name == 'prompt_usage.py':
            continue

        prompts_in_file = scan_file_for_prompts(py_file)

        for prompt_name, line_num in prompts_in_file:
            # Make path relative to root
            relative_path = py_file.relative_to(root_dir)
            usage_map[prompt_name].append((str(relative_path), line_num))

    return dict(usage_map)


def format_usage_report(usage_map: dict, all_prompts: list[str]) -> str:
    """
    Format the usage map as a readable report.

    Args:
        usage_map: Dictionary of prompt usage
        all_prompts: List of all prompt files

    Returns:
        Formatted report string
    """
    lines = ["# Prompt Usage Report\n"]
    lines.append("This file is auto-generated by `scripts/prompt_usage.py`.\n")
    lines.append("It shows which Python files use which prompt templates.\n\n")

    # Summary
    lines.append("## Summary\n")
    lines.append(f"- **Total prompts**: {len(all_prompts)}")
    lines.append(f"- **Prompts in use**: {len(usage_map)}")
    lines.append(f"- **Unused prompts**: {len(all_prompts) - len(usage_map)}\n\n")

    # Used prompts
    lines.append("## Prompt Usage\n")

    for prompt in sorted(all_prompts):
        if prompt in usage_map:
            lines.append(f"### `{prompt}`\n")
            lines.append(f"**Used in {len(usage_map[prompt])} location(s):**\n")

            for file_path, line_num in sorted(usage_map[prompt]):
                lines.append(f"- `{file_path}:{line_num}`")

            lines.append("")
        else:
            lines.append(f"### `{prompt}`\n")
            lines.append("**Status**: ⚠️ Not currently used in any Python file\n")

    # Orphaned references (prompts referenced but don't exist)
    orphaned = [p for p in usage_map.keys() if p not in all_prompts]
    if orphaned:
        lines.append("## ⚠️ Orphaned References\n")
        lines.append("These prompt files are referenced in code but don't exist:\n")
        for prompt in sorted(orphaned):
            lines.append(f"### `{prompt}`\n")
            lines.append("**Referenced in:**\n")
            for file_path, line_num in sorted(usage_map[prompt]):
                lines.append(f"- `{file_path}:{line_num}`")
            lines.append("")

    # Footer
    lines.append("\n---\n")
    lines.append("*To regenerate this report, run: `python scripts/prompt_usage.py`*\n")

    return "\n".join(lines)


def main():
    """Main entry point."""
    # Get project root (parent of scripts directory)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    prompts_dir = project_root / "prompts"

    print("=" * 60)
    print("Prompt Usage Scanner")
    print("=" * 60)

    # Find all prompts
    all_prompts = find_all_prompts(prompts_dir)
    print(f"Found {len(all_prompts)} prompt files in prompts/")

    # Generate usage map
    usage_map = generate_usage_map(project_root)

    # Generate report
    report = format_usage_report(usage_map, all_prompts)

    # Print to console
    print("\n" + report)

    # Also write to file
    output_file = prompts_dir / "USAGE.md"
    output_file.write_text(report, encoding='utf-8')
    print(f"\n✓ Report saved to {output_file.relative_to(project_root)}")


if __name__ == '__main__':
    main()
